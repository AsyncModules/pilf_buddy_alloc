# 当前bug解决方案

bug描述见[此文档](./无锁列表当前bug描述.md)。

假设b节点将被删除，b节点的前驱是a节点。线程1将要访问b节点，其操作顺序为：`访问a（即获取b的指针）-->访问b-->结束访问b`。线程2将要删除b节点，其操作顺序为：`标记b-->修改a-->释放b`。（实际上，修改a的操作不一定由线程2完成，但即使如此，修改a也一定在释放b之前。）

则在`访问a-->访问b-->结束访问b`期间，需要保证b不被释放。因为自从获取指针开始，指针指向的数据就可能失效，因此该临界区包含了访问a的部分。

我们可以将该区域分为两段，分别保证`访问a-->访问b`期间，以及`访问b-->结束访问b`期间，b不被释放。

## 引用计数

为每个链表节点增加引用计数字段。当线程正在访问该节点时，增加计数；当线程不再访问该节点时，降低计数。引用计数不包括链表节点相互链接导致的引用，也就是只包括各个线程内部的临时指针的引用。

该方法可以保证`访问b-->结束访问b`期间，b不被释放。

引用计数不会阻止并发访问、不会更改搜索函数的行为。仅在`pop`和`delete`函数的末尾，如果取到的节点的引用计数>1，则函数需要循环等待直到引用计数=1（说明只有当前线程在访问该节点）。

引用计数字段放在指针（及标记）字段之后，占用一个`usize`的空间。这样设计是为了使引用计数的不同不会导致CAS操作失败。当只有引用计数变化时，CAS操作应该成功，就像没有引用计数时的情况一样。

代码中，需要维护引用计数的位置如下：

`search_with_ptr`函数中（`get_headptr_head`函数同理）：

- 159、161行，对`t`和`t_next`的初始化，需要提升`head`和`head`后继结点的引用计数。
- 166、167行，`left_node`和`left_node_next`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 169行，`t`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 173行，`t_next`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 180行，`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升；`t`和`t_next`指向节点的引用计数下降（相当于释放`t`和`t_next`）
- 187行、201行，`left_node_next`指向节点的引用计数下降。

在`search_with_ptr`与`get_headptr_head`函数返回后，`left_node`和`right_node`指向的节点的引用计数仍提升了（该计数会在外层函数中下降）；其它节点的引用计数未被此线程改变。

`pop`函数中（`delete`函数同理）：

- 77行，`left_node`和`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 79行，`left_node`指向节点的引用计数下降。（`right_node`为空指针，不需维护引用计数）
- 104行，在函数返回前，先将`left_node`指向节点的引用计数下降。之后循环等待直到`right_node`指向节点的引用计数降到1，再返回。

`push`函数中：

- 52行，`left_node`和`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 53行，如果第一次循环，则`new_node`的引用计数提升。
- 64行，`left_node`、`right_node`和`new_node`的引用计数下降。
  
`is_empty`函数中：

- 45行，`left_node`和`right_node`的引用计数下降。

### 对删除节点的讨论

在删除节点时，假设要从a->b->c链表中删除b节点，则搜索函数返回时，获取的是a和b的引用计数。是否需要额外获得c的访问计数？我认为不需要。

不修改c.count可能导致的bug为，从b中获取到c的指针并写入a中后，c被释放导致a指向了无效区域。下面证明这个情况不可能发生。

链表的删除操作过程如下：(1)从搜索函数获取a和b的指针（并在搜索函数内部增加了a.count和b.count）=> (2)给b打上tag => (3)a.next=b.next => (4)a.count -1, b.count -1 => (5)循环等到直到b.count == 0 => (6)释放b。

如果有另一个线程同时准备删除该部分的元素，则：

1. 如果两个线程的搜索函数都找到了b，则根据哪个线程成功给b打上tag决定b归谁所有、未获得b的线程重新搜索。
2. 如果另一个线程的搜索函数找到了c，则另一个线程搜索函数的返回值可能为(a, c)或(b, c)。
3. 若另一个线程返回(a,c)，则说明另一个线程的(1)操作后于本线程的(2)操作。此时，另一个线程执行搜索函数后，b已从链表上移除（无论其被本线程或另一个线程移除）。因此，另一个线程的(2)操作开始时，本线程不会再改变a.next，而另一个线程可以正常地设置a.next = c.next。
4. 若另一个线程返回(b,c)，则说明另一个线程的(1)操作先于本线程的(2)操作。如果另一个线程的(3)操作b.next = c.next先于本线程的(3)操作a.next = b.next，则a的地址被正确设置。
5. 若另一个线程返回(b,c)，且另一个线程的(3)操作后于本线程的(3)操作，则另一个线程的(3)操作后于本线程的(2)操作。因此，另一个线程在执行(3)操作时会因为b被标记而失败。

### 使用RAII思想实现的引用计数

通过指针类的new、clone和drop函数增加和降低引用计数。

这样的话，就不需要找到每一个应增减引用计数的代码位置，手动增减引用计数了，而是根据指针的生命周期自动管理引用计数。

## 验证a节点的值

在已有引用计数的情况下，仍会发生问题的情况是b节点在增加引用计数前被删除，即`线程1访问a-->线程2修改a-->线程2释放b-->线程1访问b`的顺序。在该顺序中，线程1访问b前后，a的值一定发生了更改。

因此，在线程1获取到b的指针并增加引用计数后，增加一个验证a的值与原来相同的验证步骤。如果相同，则正常进行；如果不同，则降低b的引用计数并重新获取一次b的指针（可以使用验证时读取到的a值）。

该方法可以保证`访问a-->访问b`期间，b不被释放。

在验证过程中，a前后的值只需要指针部分相同即可（不需考虑标记字段）。