# 当前bug解决方案

bug描述见[此文档](./无锁列表当前bug描述.md)。

假设b节点将被删除，b节点的前驱是a节点。线程1将要访问b节点，其操作顺序为：`访问a（即获取b的指针）-->访问b-->结束访问b`。线程2将要删除b节点，其操作顺序为：`标记b-->修改a-->释放b`。（实际上，修改a的操作不一定由线程2完成，但即使如此，修改a也一定在释放b之前。）

则在`访问a-->访问b-->结束访问b`期间，需要保证b不被释放。因为自从获取指针开始，指针指向的数据就可能失效，因此该临界区包含了访问a的部分。

我们可以将该区域分为两段，分别保证`访问a-->访问b`期间，以及`访问b-->结束访问b`期间，b不被释放。

## 引用计数

为每个链表节点增加引用计数字段。当线程正在访问该节点时，增加计数；当线程不再访问该节点时，降低计数。

该方法可以保证`访问b-->结束访问b`期间，b不被释放。

引用计数不会阻止并发访问、不会更改搜索函数的行为。仅在`pop`和`delete`函数的末尾，如果取到的节点的引用计数>1，则函数需要循环等待直到引用计数=1（说明只有当前线程在访问该节点）。

引用计数字段放在指针（及标记）字段之后，占用一个`usize`的空间。这样设计是为了使引用计数的不同不会导致CAS操作失败。当只有引用计数变化时，CAS操作应该成功，就像没有引用计数时的情况一样。

代码中，需要维护引用计数的位置如下：

`search_with_ptr`函数中（`get_headptr_head`函数同理）：

- 159、161行，对`t`和`t_next`的初始化，需要提升`head`和`head`后继结点的引用计数。
- 166、167行，`left_node`和`left_node_next`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 169行，`t`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 173行，`t_next`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 180行，`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升；`t`和`t_next`指向节点的引用计数下降（相当于释放`t`和`t_next`）
- 187行、201行，`left_node_next`指向节点的引用计数下降。

在`search_with_ptr`与`get_headptr_head`函数返回后，`left_node`和`right_node`指向的节点的引用计数仍提升了（该计数会在外层函数中下降）；其它节点的引用计数未被此线程改变。

`pop`函数中（`delete`函数同理）：

- 77行，`left_node`和`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 79行，`left_node`指向节点的引用计数下降。（`right_node`为空指针，不需维护引用计数）
- 104行，在函数返回前，先将`left_node`指向节点的引用计数下降。之后循环等待直到`right_node`指向节点的引用计数降到1，再返回。

`push`函数中：

- 52行，`left_node`和`right_node`指向原节点的引用计数下降、指向新节点的引用计数提升。
- 53行，如果第一次循环，则`new_node`的引用计数提升。
- 64行，`left_node`、`right_node`和`new_node`的引用计数下降。
  
`is_empty`函数中：

- 45行，`left_node`和`right_node`的引用计数下降。

## 验证a节点的值

在已有引用计数的情况下，仍会发生问题的情况是b节点在增加引用计数前被删除，即`线程1访问a-->线程2修改a-->线程2释放b-->线程1访问b`的顺序。在该顺序中，线程1访问b前后，a的值一定发生了更改。

因此，在线程1获取到b的指针并增加引用计数后，增加一个验证a的值与原来相同的验证步骤。如果相同，则正常进行；如果不同，则降低b的引用计数并重新获取一次b的指针（可以使用验证时读取到的a值）。

该方法可以保证`访问a-->访问b`期间，b不被释放。

在验证过程中，a前后的值只需要指针部分相同即可（不需考虑标记字段）。