# 无锁链表论文阅读及修改方案

## 无锁链表论文的设计

解决的问题：CAS操作无法保证在链表节点删除过程中，被删除元素的指针依然指向新的链表头。

![alt text](image.png)

![alt text](image-1.png)

因此，将删除操作分为两段：先在删除节点上增加“删除标记”（逻辑删除），再执行指针修改操作（物理删除）

![alt text](image-2.png)

插入和删除都会使用`search`函数，其在搜索过程中还会物理删除具有删除标记的节点，从而避免执行删除操作的线程被抢占而无法及时物理删除造成的死锁。

## 论文的实现

### `search`函数

```C
private Node *List::search(KeyType search_key, Node **left_node) {
    Node *left_node_next, *right_node;
    search_again:
    do {
        Node *t = head;
        Node *t_next = head.next;
        /* 1: Find left_node and right_node */
        do {
            if (!is_marked_reference(t_next)){
                (*left_node) = t;
                left_node_next = t_next;
            }
            t = get_unmarked_reference(t_next);
            if (t == tail) break;
            t_next = t.next;
        } while(is_marked_reference(t_next) || (t.key < search_key));/*B1*/
        right_node = t;
        /* 2: Check nodes are adjacent*/
        if (left_node_next == right_node)
            if ((right_node != tail) && is_marked_reference(right_node.next))
                goto search_again; /*G1*/
            else
                return right_node; /*R1*/
        /* 3: Remove one or more marked nodes */
        if (CAS(&(left_node.next), left_node_next, right_node))/*C1*/
            if ((right_node != tail) && is_marked_reference(right_node.next))
                goto search_again; /*G2*/
            else
                return right_node; /*R2*/
    } while (true); /*B2*/
}
```

首先，该链表为从小到大的有序链表，因此查找到的位置为`left_node`满足`left_node`是小于`search_key`的最后一个元素，而返回的位置`right_node`是大于等于`search_key`的第一个元素。

函数的结构分为三段，位于一个循环中。

（注：后文出现以符号代表节点的情况，均指它们作为指针指向的节点。）

第一段（Find left_node and right_node）：

- 通过两个相邻指针`t`和`t_next`在链表上移动，直到`t`是大于等于`search_key`的第一个节点，且`t`指向的节点未被标记。\*1`t`和`t_next`保持相邻（除非`t`位于链表尾，则`t` == `t_next`）。
- 在循环中更新`left_node`和`left_node_next`：如果`t`指向的节点的前驱未被标记\*2、，则将`left_node`和`left_node_next`更新为上一次循环的`t`和`t_next`值。
- 循环结束后，将`right_node`赋值为`t`。

\*1：代码中写的是`t_next`未被标记。因为其含义是`t_next`的值未被标记，也就是`t`指向的节点（其指针的值为`t_next`）未被标记。

\*2: 代码中写的是`t_next`未被标记，根据\*1，其含义为`t`指向的节点未被标记。但此时的`t`和`t_next`还未更新，因此站在被循环更新后的变量的角度看，被标记的节点为`t`指向的节点的前驱的。

通过这一过程，各个指针的关系如下：

1. 若待寻找的节点（即小于`search_key`的最后一个节点）不是尾部、不是被标记的节点的前驱、不是被标记节点：`left_node == 待寻找的节点 => left_node_next == right_node == 返回的节点 == t => t_next`
2. 若待寻找的节点是尾部：`left_node == 待寻找的节点 => left_node_next == right_node == 返回的节点 == t == t_next`
3. 若待寻找的节点是被标记的节点的前驱：`left_node == 待寻找的节点 => left_node_next == 被标记的节点 => right_node == t => t_next`
4. 若待寻找的节点是被标记的节点：`left_node => left_node_next == 被标记的节点 == 待寻找的节点 => right_node == t => t_next`

第二段（Check nodes are adjacent）：

外层if筛选出了情况1、2。

内层if：如果`right_node`不是尾部，且`right_node`被标记，则重新寻找（注：这次重新寻找，若标记仍未删除则会进入情况4）。否则，直接返回`right_node`。

第三段（Remove one or more marked nodes）：

进入第三段的只有情况3、4。

首先在外层if中使用CAS，判断如果`left_node`的后继是`left_node_next`（即，`left_node`和`left_node_next`间未插入新节点，且`left_node_next`未被删除），则将`left_node`的后继设置为`right_node`。（即，删除了被标记的`left_node_next`）

如果删除失败，则重新查找（通过`while`循环实现）。

如果删除成功，进入内层if，功能与第二段的内层if相同。

### `find`函数

```C
public boolean List::find(KeyType search_key) {
    Node *right_node, *left_node;
    right_node = search(search_key, &left_node);
    if((right_node == tail) ||
        (right_node.key != search_key))
        return false;
    else
    return true;
}
```

### `insert`函数

```C
public boolean List::insert(KeyType key) {
    Node *new_node = new Node(key);
    Node *right_node, *left_node;
    do{
        right_node = search(key, &left_node);
        if ((right_node != tail)&&(right_node.key == key)) /*T1*/
            return false;
        new_node.next = right_node;
        if (CAS(&(left_node.next), right_node, new_node))/*C2*/
            return true;
    } while (true);/*B3*/
}
```

论文的链表是一个有序且元素互不相同的链表，因此需要查找插入位置，且链表中已有相同元素时会报插入失败。

### `delete`函数

```C
public boolean List::delete(KeyType search_key) {
    Node *right_node, *right_node_next, *left_node;
    do {
        right_node = search(search_key, &left_node);
        if ((right_node == tail) || (right_node.key != search_key)) /*T1*/
            return false;
        right_node_next = right_node.next;
        if (!is_marked_reference(right_node_next))
            if (CAS(&(right_node.next), /*C3*/ right_node_next, get_marked_reference(right_node_next)))
                break;
    } while (true);/*B4*/
    if (!CAS(&(left_node.next), right_node, right_node_next)) /*C4*/
        right_node = search(right_node.key, &left_node);
    return true;
}
```

如论文所示，链表项删除分为两个步骤。

1. 找到要删除的链表项，使用CAS标记它。其中，如果找不到链表项，则提前返回；如果找到的项已有标记，或者CAS操作失败，则重新寻找要删除的项。否则，进入第二步。
2. 对要删除链表项的前驱做CAS操作，修改其next指针。如果CAS操作失败，则执行search函数，对要删除的项再进行搜索，从而使用search函数删除已被标记的待删除项。

## 我们链表的修改方案

根据堆分配器的使用情况，决定如此设计链表的接口：

`push`：将一项插入到链表头。

`pop`：从链表头删除一项，并返回其内容。

`delete`：从链表中删除指定的一项。

`is_empty`：判断链表是否为空。

<!-- `iter`：返回对链表的不可变迭代器。工作量太大，暂不实现 -->

与原有接口相比，删除了迭代器，其功能改为使用`delete`实现。

此外，我们的链表和论文的链表还有一个不同：

论文的链表中，`head`和`tail`都是指向两个空节点的指针，这两个空节点之间才是存储实际数据的节点。但我们的链表没有`tail`指针，而`head`直接指向存储实际数据的第一个节点。因此，论文中的`head`对应我们的`&head`，论文中的`tail`对应我们的`EMPTY_FLAG`。

由于我们的链表与论文的链表在接口、排列上不尽相同，因此以下描述各个接口的实现（使用类似Rust的伪代码，不考虑位置无关）：

### `push`函数

```Rust
pub fn push(&mut self, item: *mut usize) {
    loop {
        let (left_node, right_node) = self.get_headptr_head();
        let new_node = item;
        *new_node = right_node;
        if CAS(left_node, right_node, new_node) {
            return;
        }
    }
}
```

`item`指链表项携带的信息，也就是空闲块的首地址（链表首地址）。因此，`item`同时也是指向链表项的指针。

### `pop`函数

```Rust
pub fn pop(&mut self) -> Option<*mut usize> {
    loop {
        // 查找与逻辑删除
        do {
            let (left_node, right_node) = self.get_headptr_head();
            if right_node == EMPTY_FLAG {
                return false;
            }
            let right_node_next = *right_node;
            if !right_node_next.is_marked() { // 此处实际判断的是right_node是否被标记
                if CAS(right_node, right_node_next, right_node_next.mark()) {
                    break;
                }
            }
        }
        // 物理删除
        if !CAS(left_node, right_node, right_node_next) {
            let (_, _) = self.search_with_ptr(right_node);
            // 之后回到大循环，因为需要重新pop一项出来
        }
        else {
            return Some(right_node)
        }
    }
}
```

`right_node`即为指向弹出块的指针，也是获取的空闲块的首地址

### `delete`函数

```Rust
// 返回值true代表链表中有所找项并成功删除；false代表没有所找项。
// 不会出现链表中有所找项但删除失败的情况。
pub fn delete(&mut self, item: *mut usize) -> bool {
    // 查找与逻辑删除
    do {
        let (left_node, right_node) = self.search_with_ptr(item);
        if (right_node == EMPTY_FLAG) || (right_node != item) {
            return false;
        }
        let right_node_next = *right_node;
        if !right_node_next.is_marked() { // 此处实际判断的是right_node是否被标记
            if CAS(right_node, right_node_next, right_node_next.mark()) {
                break;
            }
        }
    }
    // 物理删除
    if !CAS(left_node, right_node, right_node_next) {
        let (_, _) = self.search_with_ptr(right_node);
    }
    return true;
}
```

### `search_with_ptr`函数

注意：此函数的意义与论文的`search`有所不同。论文的`search`是按值查找，而此处的`search_with_ptr`为按指针查找。进行这样的修改，是因为一般的链表存储的信息在链表项之中，而我们的链表存储的信息是链表项的地址。这也保证了，两种链表项中存储的信息都是不可修改的。

```Rust
fn search_with_ptr(&mut self, item: *mut usize) -> (*mut usize, *mut usize) { // 两个返回值分别为left_node和right_node
    let left_node = EMPTY_FLAG;
    let left_node_next = EMPTY_FLAG;
    let right_node = EMPTY_FLAG;
    loop {
        loop {
            let t = &mut head;
            let t_next = head;

            /* 1: Find left_node and right_node */
            loop {
                if (!t_next.is_marked()){
                    *left_node = t;
                    left_node_next = t_next;
                }
                t = t_next.unmark();
                if t == EMPTY_FLAG {
                    break;
                } 
                t_next = *t;
                // rust没有do-while，因此这样退出循环
                if !(t_next.is_marked() || (t != item)) { // if的第二个条件，将原论文的按值查找改为了按指针查找
                    break;
                }
            }
            right_node = t;

            /* 2: Check nodes are adjacent*/
            if left_node_next == right_node {
                if (right_node != EMPTY_FLAG) && (*right_node).is_marked() {
                    break;
                }
                else {
                    return (left_node, right_node);
                }
            }
            
            /* 3: Remove one or more marked nodes */
            if (CAS(left_node, left_node_next, right_node)) {
                if (right_node != EMPTY_FLAG) && (*right_node).is_marked() {
                    break;
                }
                else {
                    return (left_node, right_node);
                }
            }
        }
    }
}
```

### `get_headptr_head`函数

该函数为`search_with_ptr`函数的变体，用于为`push`和`pop`函数获取对应的`left_node`和`right_node`（即为`&mut head` 和 `head`）。该函数还会像`search_with_ptr`函数一样清理已标记节点，从而保证`left_node`和`right_node`符合要求。

该函数对`search_with_ptr`函数的修改仅有，在1阶段的循环继续条件中删除了`t != item`，从而使一阶段的循环仅用于跳过被标记的节点。

```Rust
fn get_headptr_head(&mut self) -> (*mut usize, *mut usize) { // 两个返回值分别为&mut head和head
    let left_node = EMPTY_FLAG;
    let left_node_next = EMPTY_FLAG;
    let right_node = EMPTY_FLAG;
    loop {
        loop {
            let t = &mut head;
            let t_next = head;

            /* 1: Find left_node and right_node */
            loop {
                if (!t_next.is_marked()){
                    *left_node = t;
                    left_node_next = t_next;
                }
                t = t_next.unmark();
                if t == EMPTY_FLAG {
                    break;
                } 
                t_next = *t;
                // rust没有do-while，因此这样退出循环
                if !t_next.is_marked() {
                    break;
                }
            }
            right_node = t;

            /* 2: Check nodes are adjacent*/
            if left_node_next == right_node {
                if (right_node != EMPTY_FLAG) && (*right_node).is_marked() {
                    break;
                }
                else {
                    return (left_node, right_node);
                }
            }
            
            /* 3: Remove one or more marked nodes */
            if (CAS(left_node, left_node_next, right_node)) {
                if (right_node != EMPTY_FLAG) && (*right_node).is_marked() {
                    break;
                }
                else {
                    return (left_node, right_node);
                }
            }
        }
    }
}
```

### `is_empty`函数

直接判断`head`的值的话，则当表中只有被标记的节点时，会引起误判。因此使用`get_headptr_head`实现。

```Rust
pub fn is_empty(&mut self) -> bool {
    let (_, right_node) = self.get_headptr_head();
    return right_node == EMPTY_FLAG;
}
```