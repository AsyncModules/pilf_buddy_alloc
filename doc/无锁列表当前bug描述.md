# 无锁链表当前bug描述

## 描述

在commit `eb5129fd79434e2ec426d0a434e894cfc1ac5aae`版本中，对堆分配器进行性能测试，或者执行新增的堆分配器测例中的某些，均会发生运行错误，主要有**访存错误**和**`unwarp`一个`None`值**这两种错误形式。

经过排查后发现，bug的触发条件为**并行地对堆进行多次`push`或`pop`操作**。

## 原因

该bug的产生原因已经明确。原因为**被删除的链表节点被复用，导致链表操作取到脏数据**。

![链表bug示意.png](链表bug示意.png)

如上图所示，如果被删除的节点被复用（且数据被更改），则算法无法处理该情况，其原因有二：

1. 更改后的数据（很可能）没有标记，从而使算法无法判断出该指针无效。
2. 更改后的数据（很可能）不再指向原链表，使算法的遍历链表过程无法继续。（算法的遍历链表操作依赖于被删除的节点仍指向原链表）

在链表论文的原文中，也提到了该链表的正确性依赖于**被标记的节点不会被取消标记**。实际上，如果要求链表完全可靠，则被删除的节点不能被复用，而应永远保持它们的值（也就是删除标记+指向原链表的指针），实际上也相当于将这部分内存泄漏了。

![alt text](image-3.png)

原文的代码也是这么写的：创建节点时，`new`了`Node`对象，但删除节点时，没有`delete`它。

![alt text](image-4.png)

![alt text](image-5.png)

然而，这样的内存泄漏是堆分配器不可接受的。

## 解决方案？

对于该问题，我还没有想出有效的解决方案。以下是一些思路，但我已经判断了它们不可行。可能在进一步修改后，可以得到可行的思路，因此我将它们记下。

### 1. 将指针所在的内存区域保留在堆分配器内部

例如：需要1个`usize`的空间，则堆分配器申请2个`usize`的空间`space: [usize; 2]`，其中`space[0]`保留在堆分配器内部，不向外提供；`space[1]`提供给外界。从而使`space[0]`中存储的指针和标记不变。

**问题：** 

1. 即使在分配后保持不变，但在回收这部分空间时，`space[0]`的值仍会变化（且一定会清除删除标记）。因此，不能完全解决以上的bug。
2. 造成了空间的浪费（尤其在分配小内存时）

### 2. 用版本字段替代已删除字段

当要标记某个节点为已删除时、或者复用一个已删除的节点时，增加该节点的版本字段。这样，算法就可以识别出已删除且已复用的节点。

**问题：** 

1. 将该内存分配给外界时，版本字段仍会遭到破坏
2. 已删除且已复用的节点的指针部分仍被破坏了
3. 版本字段需要和指针放在一个可被原子操作的内存单元中，因此版本字段可以使用的只有指针字段因为对齐而不使用的后三位，导致版本只能取8个值，可靠性也不高

### 3. 结合1和2

既保持指针所在的`usize`区域不分配给外界，又使用版本字段替换删除标记。

**问题：**

1. 方法2的问题2、3依然存在
2. 在进行区域的切分和合并时，合并会导致靠后区域的指针成为可分配的内存，再将该区域不切分地分配出去，即会导致该指针被分配给外界