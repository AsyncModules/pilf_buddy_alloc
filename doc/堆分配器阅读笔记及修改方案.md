# 堆分配器阅读笔记及修改方案

时间：2025.4.12

## 初步分析

这个文件实现了使用buddy_system的堆分配器。其使用多个`LinkedList`记录不同大小的空闲区域，同时还具有`user`、`allocated`、`total`等统计信息。

对于统计信息的同步很简单，直接使用`AtomicUsize`即可。对于空闲区的同步，在假设链表已经实现了无锁同步的基础上，还需要关注多个读-写操作间的数据有效性。

**`Heap::add_to_heap`**：其只包含写操作，因此不涉及数据有效性问题。

**`Heap::alloc`**：该函数先判断对应大小的`LinkedList`是否有空虚块（读操作），如果没有，则从更大的`LinkedList`中切分。切分过程只涉及写操作，不涉及数据有效性问题。

不过，这个函数可能会产生未合并的空闲块。原因是，切分过程从更大的链表获取到空闲块并切分后，会先将两个块都push入较小的链表，再从链表中pop一个出来。如果在push和pop之间，对应的链表中插入了新的空闲块，则会把两个可合并的空闲块留在链表中。未合并的空闲块不会被`dealloc`的合并过程检测到，因为`dealloc`的合并过程只会检测新空闲块是否和某一个已有空闲块可合并。未合并的空闲块会导致性能问题。若要解决，则可以把两次push、一次pop改成一次push。

**`Heap::dealloc`**：该函数由于在插入空闲块时，采用了先插入再合并的策略，再加上需要频繁检查链表中是否有可合并的块，因此具有大量相关的读写操作，难以分析。我觉得，需要先将“先插入再合并”改为“先合并再插入”，减少写操作的数量，再进行同步分析。

## 第二次分析

在初步分析后，得出了需要先删除`alloc`和`dealloc`函数中冗余的链表操作的结论。删除这些操作后，再次分析这些函数：

### 链表操作和对统计信息的操作之间的同步问题

对二者的操作相互独立，没有数据依赖。因此，可以不考虑它们之间的同步问题，而后果仅是某些情况下，统计信息会滞后于链表的实际情况。

### `alloc`函数

先判断链表是否为空，再从链表中pop内容（并假设一定能pop出内容），此处有同步问题。因此需要给pop加入失败重试。

### `dealloc`函数

查找和取出合成了一个链表操作`delete`，因此不需再考虑查找和取出间的同步问题。

因为取出的节点都由本线程单独持有，因此pop和push间没有同步问题。

然而，dealloc函数在遇到块合并时，如果一次合并太多块，会先从链表中将要合并的块全部取出，再将合并后的块放入链表。这会导致，当线程在取出待合并块之后、放入合并块之前的时机被抢占，则大量的内存资源会被该线程持有，导致其它线程可能无法正常完成分配，甚至导致死锁。该问题目前还未想到解决方案。